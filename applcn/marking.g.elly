# add markup to convert English text into shallow XML
# marking.g.elly

#
# subprocedures
p:lxtd  # adding a tagged element on the left to a list on the right
_
  split
  right
  back
  delete to >
  store    tmp
  insert < tmp
  (typg)
  merge
__
p:rxtd  # adding tagged element on the right to list on the left
_
  left
  split
  back
  find < >
  append <
  insert < typg
  append >
  right
  append </
  insert < typg
  append >
  merge
__
p:typg  # left generation of element tagged as specified type
_
  append <
  insert < typg
  append >
  left
  append </
  insert < typg
  append >
__
p:twob  # simple spaced output for 2-branch rule
_
  left
  space
  right
__

#
# syntax rules
g:SENT->SS
#?>>?
 >>+0
_
  append <sent>
  linefeed
  left
  append </sent>
__
g:SS->SS PUNC[~stop]
_
  left
  linefeed
  append <punc>
  right
  append </punc>
__
g:SS->PUNC[~start] SS
_
  append <punc>
  left
  append </punc>
  right
__
g:SS[|segm]->SEGM
__
g:SS[|segm]->SS[|-segm] SEGM
_
  left
  linefeed
  right
__
g:SS->SS PUNC[~-stop]
_
  left
  linefeed
  append <punc>
  right
  append </punc>
__
g:SS->SS CONJ
_
  left
  linefeed
  var typg=conj
  (brack)
__
g:SS->CONJ
_
  var typg=conj
  (brack)
__

p:brack   # handle bracketing
_
  var lbr=
  var rbr=
  split
  right
  back
  if ~lbr=
    insert < lbr
    end
  if typg=
    merge
  else
    append <
    insert < typg
    append >
    merge
    append </
    insert < typg
    append >
    end
  if ~rbr=
    insert < rbr
    end
__
g:SEGM[|*unique]->ELEM
 >>*l
__
g:SEGM[|*unique]->SEGM ELEM
#?>>?
 l[!pro] r[!n]>>--
 l[!n] r[!n]>>*r--
 l[!v] r[!v]>>*r----
            >>*r
_
  left
  linefeed
  right
__
g:SEGM->SEGM PUNC
 >>*l----
_
  left
  linefeed
  append <punc>
  right
  append </punc>
__
g:SEGM->SEGM CONJ
 >>*l----
_
  left
  linefeed
  append <conj>
  right
  append </conh>
__

g:ELEM->ADV[~mod] NCLU
 >>[!n]+
_
  var typg=adv
  (typg)
  right
__
g:ELEM->NCLU[:-dit, prep,-poss]
#?>>?
  >>+0
__
g:ELEM->NCLU[:-dit,-prep,-poss]
 >>[!n]
__
g:ELEM->NCLU[:dit]
 >>[!n]+
_
  append <conj>that</conj>
  linefeed
  left
__
g:ELEM->PRO
 >>[!n,pro]
_
  var typg=pro
  (typg)
__
g:ELEM[^*l]->VCLU[^-to,-infn]
 >>[!v]
__
g:ELEM[^*l]->VCLU[^-to, infn]
__
g:ELEM->VCLU[^to] NCLU
 >>+
_
  left
  linefeed
  right
__
g:ELEM->THAT VCLU[^s]
 >>++
_
  append <dem>that</dem>
  right
__
g:ELEM->ELEM[^dit] THAT
 >>++
_
  left
  linefeed
  append <conj>that</conj>
__
g:ELEM->DATE
_
  var typg=date
  (typg)
__
g:ELEM->TIME
_
  var typg=time
  (typg)
__
g:ELEM->DEM[:ind]
 >>--
_
  var typg=dem
  (typg)
__
g:ELEM->ADJ
 >>----
_
  var typg=adj
  (typg)
__
g:ELEM->ADV
 >>----
_
  var typg=adv
  (typg)
__
g:ELEM->QUAN[:ind]
 >>----
_
  append <quan>
  right
  append </quan>
__
g:ELEM[^dit]->PEXP[|eg]
 >>++
_
  append <pexp>
  left
  append </pexp>
__
g:ELEM[^dit]->PEXP[|quo] PUNC[|*r,quo]
 >>------
_
  var typg=quote
  (typg)
  linefeed
  append <punc>
  right
  append </punc>
__
g:ELEM[^dit]->PEXP[|eg,-cm]
_ 
  var typg=pexp
  (typg)
__

g:PEXP[|eg,cm]->PUNC[|com] PEXP[|eg,-cm]
 >>++
_
  (pbeg)
  linefeed
__

g:PEXP[|eg]->PEXP[|eg,cm] PUNC[|com]
 >>++
_
  left
  append <punc>
  right
  append </punc>
__

p:pbeg
_
  append <punc>
  left
  append </punc>
  linefeed
  right
__
g:PEXP[|*l,nom]->PUNC[|*l] NCLU
 >>+
_
  (pbeg)
__
g:PEXP[|*l,vrb]->PUNC[|*l] VCLU[^-ed,-ing]
 >>+
_
  (pbeg)
__
g:PEXP[|*l,vrb,ed]->PUNC[|*l] VCLU[^ed]
 >>+
_
  (pbeg)
__
g:PEXP[|*l,vrb,ing]->PUNC[|*l] VCLU[^ing]
 >>+
_
  (pbeg)
__
g:PEXP[|*l]->PUNC[|*l] SEGM
 >>+
_
  (pbeg)
__
g:PEXP[|det]->PUNC[|*l] DET
_
  (pbeg)
__

p:pend
_
  append <
  insert < typg
  append >
  left
  linefeed
  append <punc>
  right
  append </punc></
  insert < typg
  append >
__
g:NCLU->PEXP[|nom,eg,-cm]
 >>++
_
  var typg=nclu
  (typg)
__
g:NCLU->PEXP[|nom] PUNC[|*r]
_
  append <nclu>
  split
  left
  back
  find <nclu> <
  delete 6 <
  find </nclu> <
  delete 7 <
  merge
  linefeed
  append <punc>
  right
  append </punc></nclu>
__
g:VCLU->PEXP[|vrb,-ed,-ing] PUNC[|*r]
_
  var typg=vclu
  (pend)
__
g:VCLU[^ed]->PEXP[|vrb,ed] PUNC[|*r]
_
  var typg=vclu
  (pend)
__
g:VCLU[^ing]->PEXP[|vrb,ing] PUNC[|*r]
_
  var typg=vclu
  (pend)
__
g:SEGM->PEXP[|-nom,-vrb] PUNC[|*r]
 >>--
_
  var typg=pexp
  (pend)
__
g:DET->PEXP[|det] PUNC[|*r]
_
  append <det>
  left
  append <punc>
  right
  append </punc></det>
__
g:PEXP[|*l]->PEXP PUNC[|emb]
_
  left
  linefeed
  append <punc>
  right
  append </punc>
__

g:NCLU[:*l]->NOUN
_
  append <nclu>
  var typg=noun
  (brack)
  append </nclu>
__
g:NCLU[:*l,*r,det]->DET[:sgl] NCLU[:-det,-prep,-plur]
_
  var typg=det
  (lxtd)
__
g:NCLU[:*l,*r,det]->DET[:-sgl] NCLU[:-det,-prep]
_
  var typg=det
  (lxtd)
__
g:NCLU[:*r,prep]->PREP NCLU[:-prep]
_
  var typg=prep
  (lxtd)
__
g:NCLU[:*l]->NCLU POSTP
_
  var typg=postp
  (rxtd)
__
g:NCLU[:*l]->NCLU ADJ
 r[$prd]>>+
        >>----
_
  var typg=adj
  (rxtd)
__
g:NOUN->NOUN NUM
 >>++
_
  (twob)
__
g:NCLU->NUM
 >>--
_
  append <nclu>
  var typg=num
  (typg)
  append </nclu>
__
g:NCLU[:prep]->PREP YEAR
_
  append <time>
  (twob)
  append </time>
__
g:NCLU[:*l,*r,det]->DEM[:-sgl] NCLU[:-det,-prep]
_
  var typg=dem
  (lxtd)
__
g:NCLU[:*l,*r,det]->DEM[:sgl]  NCLU[:-det,-prep,-plur]
 >>++
_
  var typg=dem
  (lxtd)
__
g:NCLU[:*r]->ADJ NCLU[:-det,-prep,-num]
 >>++
_
  var typg=adj
  (lxtd)
__
g:NCLU[:*r,num]-> NUM NCLU[:-det,-prep,-num]
_
  var typg=num
  (lxtd)
__
g:NCLU[:*r,det]->QUAN NCLU[:-prep,-num]
_
  var typg=quan
  (lxtd)
__
g:NCLU->NCLU[:poss] NCLU[:-poss]
 >>+
__
g:NCLU->DET NUM
 >>--
_
  append <nclu>
  var typg=det
  (typg)
  append <num>
  right
  append </num></nclu>
__

g:NOUN->UNKN
__
g:NOUN->PRO[%mod]
_
  var typg=pro
  (typg)
__
g:NOUN[:*l,poss]->NOUN APOS
_
  (twob)
__
g:NOUN->VERB SUFX[#vTOn]
_
  (twob)
__
g:NOUN->ADJ SUFX[#aTOn]
_
  (twob)
__
g:NOUN->NOUN SUFX[#nTOn]
_
  (twob)
__
g:NOUN[:ing]->VERB XING
_
  (twob)
__
g:NOUN[:hyph]->NOUN[:-hyph] HYPH
__
g:NOUN[:*r]->NOUN[:hyph] NOUN
#?>>?
  >>++
__
g:NOUN[:*r,cjn]->NOUN[:-hyph,-plur,-cjn,-ing] NOUN[:-cjn,ing]
_
 (twob)
__
g:NOUN[:*r,cjn]->NOUN[:-hyph,-plur,-cjn,-ing] NOUN[:-cjn,-ing]
#?>>?
  >>+
_
 (twob)
__
g:ADJ[%*r]->NOUN[:hyph] ADJ
 >>++
__
g:PRO[%*r]->PREP PRO[%-nom]
_
  var typg=prep
  (typg)
  right
__

g:VCLU[^*l]->VERB
_
  append <vclu>
  var typg=verb
  (typg)
  append </vclu>
__
g:VCLU[^*r]->ADV VCLU
_
  var typg=adv
  (lxtd)
__
g:VCLU[^*l]->VCLU ADV[~-mod]
  r[$deg]>>+0
  r[$prd]>>++++
  >>----
_
  var typg=adv
  (rxtd)
__
g:VCLU[^hav,*r]->HAVE VCLU[^-hav]
_
  var typg=aux
  (lxtd)
__
g:VCLU[^aux,*r]->AUXL VCLU[^-aux]
_
  var typg=aux
  (lxtd)
__
g:VCLU[^*r]->BE VCLU[^ing,-hav]
 >>++
_
  var typg=aux
  (lxtd)
__
g:VCLU[^*r,pass]->BE VCLU[^ed,-hav]
 >>+
_
  var typg=aux
  (lxtd)
__

g:ELEM->PREP PCLS[^ing]
 >>+
_
  var typg=prep
  (lxtd)
__
g:PCLS[^*l]->VERB[^ing] NCLU
_
  append <clause><vclu><verb>
  left
  append </verb></vclu>
  linefeed
  right
  append </clause>
__
g:PCLS[^*l]->VERB[^ing] PRO[%-ind]
_
  append <clause><vclu><verb>
  left
  append </verb></vclu><pro>
  right
  append </pro></clause>
__

g:VERB->UNKN
 >>-
__
g:VERB[^*r,infn]->TO VERB[^-aux]
 >>++
_
  (twob)
__
g:VERB[^*r]->VERB[^-beaj] VERB[^infn]
 >>++
_
  (twob)
__
g:VERB[^beaj]->ADJ[%to] TO
 l[$spat]>>+
_
  append [be]
  space
  (twob)
__
g:VERB[^*r]->VERB[^proc] VERB[^ing]
 >>++
_
  (twob)
__
g:VERB->NOUN SUFX[#nTOv]
_
  (twob)
__
g:VERB->ADJ SUFX[#aTOv]
_
  (twob)
__
g:VERB[:*r]->NOUN[:hyph] VERB
__
g:VERB[^beaj]->BE ADJ[%-ed,-ing]
_
  (twob)
__
g:VERB[^*l,to]->VERB[^beaj] TO
 >>+
_
  (twob)
__
g:VERB->BE
 >>-
__
g:VERB->HAVE
 >>-
__

g:BE->BE XED
 >>+
_
  (twob)
__
g:BE->BE XING
 >>+
_
  (twob)
__
g:HAVE->HAVE XED
 >>+
_
  (twob)
__
g:HAVE->HAVE XING
 >>+
_
  (twob)
__

g:ADJ->NOUN SUFX[#nTOa]
_
  (twob)
__
g:ADJ[%*r]->NOUN[:hyph] ADJ
__
g:ADJ[%*r]->ADV ADJ
 l[$deg]>>+++
_
  var typg=adv
  (typg)
  right
__
g:ADJ[%ed]->VERB[^ed]
 >>-
__
g:ADJ[%ing]->VERB[^ing]
 >>-
__
g:ADJ->VERB SUFX[#vTOa]
__
g:ADJ->DET ADJ
 >>----
_
 (twob)
__

g:ADV->ADJ SUFX[#aTOr]
 >>[$prd]
_
  (twob)
__
g:ADV->VERB SUFX[#vTOr]
_
  (twob)
__
g:ADV->ADV ADV
 >>+
_
  (twob)
__
g:PREP->ADJ TO
 l[$spat]>>++
         >>--
_
  (twob)
__

g:NUM-> MONY NUM
__
g:NUM->ADJ[%mod] NUM
 >>+++
_
  var typg=adj
  (typg)
  right
__

#
# simple inflections
g:NOUN[:*l,plur]->NOUN[:-*l,-*r] XS
_
  (twob)
__
g:NOUN[:plur]->UNKN XS
_
  (twob)
__
g:VERB->UNKN XS
_
  (twob)
__
g:VERB[^ed]->UNKN XED
_
  (twob)
__
g:VERB[^ing]->UNKN XING
 >>-
_
  (twob)
__
g:VERB[^*l,s]->VERB[^-*l,-*r] XS
_
  (twob)
__
g:VERB[^*l,ed]->VERB[^-*l,-*r] XED
 >>++
_
  (twob)
__
g:VERB[^*l,ing]->VERB[^-*l,-*r] XING
_
  (twob)
__
g:VERB[^*l]->VERB[^ptcl] PTCL
 >>+
_
  (twob)
__
g:ADJ[%*l]->ADJ[%-*l,-*r] XER
_
  (twob)
__
g:ADV->ADV XER
_
  (twob)
__
g:ADJ[%*l]->ADJ[%-*l,-*r] XEST
_
  (twob)
__

g:DEM[:*r]->QUAN DEM[:ind]
_
  var typg=quan
  (lxtd)
__
g:DEM[:*r]->PREP DEM[:ind]
 >>-
_
  var typg=prep
  (lxtd)
__
g:DATE[:*r]->PREP DATE
_
  var typg=prep
  (lxtd)
__
g:TIME[:*r]->PREP TIME
_
  var typg=prep
  (lxtd)
__

g:CONJ->ADV[~mod] CONJ
 >>+
_
  append <mod>
  left
  append </mod>
  right
__

g:QUAN->ADV[~prox] QUAN
_
  (twob)
__

#
# predicate negation
g:AUXL[^neg,*l]->AUXL[^-neg] NEGN
_
  (twob)
__
g:BE[^neg,*l]->BE[^-neg] NEGN
_
  (twob)
__
g:HAVE[^neg,*l]->HAVE[^-neg] NEGN
_
  (twob)
__

#
# special contextual check
g:DEM[:*r,dit]->THAT DEM
_
  right
__
g:DET[:*r,dit]->THAT DET
_
  right
__

g:QUAN->THERE BE
_
  (twob)
__

#
# internal dictionary
d:- <- HYPH
__
d:in   <- PREP
__
d:of   <- PREP
__
d:on   <- PREP
__
d:by   <- PREP
__
d:at   <- PREP
__
d:into <- PREP
__
d:to   <- PREP
__
d:for  <- PREP
__
d:with <- PREP
__
d:from <- PREP
__
d:over <- PREP
__
d:through <- PREP
__
d:outside <- PREP
__
d:against <- PREP
__
d:across  <- PREP
__
d:about   <- PREP
__
d:above   <- PREP
__
d:like    <- PREP
 >>+
__
d:except  <- PREP
__

d:to   <- TO
__

d:ago  <- POSTP
__

d:a   <- DET[:sgl]
__
d:an  <- DET[:sgl]
__
d:the <- DET
__

d:this <- DEM[:ind,sgl]
__
d:that <- DEM[:ind,sgl]
__
d:that <- THAT
__
d:these<- DEM[:ind]
__
d:those<- DEM[:ind]
__
d:my   <- DEM
__
d:your <- DEM
__
d:his  <- DEM[:ind]
__
d:her  <- DEM
__
d:its  <- DEM
__
d:our  <- DEM
__
d:their<- DEM
__
d:such <- DEM[:ind]
__
d:which <- DEM[:ind]
__

d:who  <- CONJ
__
d:which<- CONJ
__
d:where<- CONJ
__
d:while<- CONJ
__
d:how  <- CONJ
__

d:all  <- QUAN[:ind]
__
d:any  <- QUAN[:ind]
__
d:some <- QUAN[:ind]
__
d:many <- QUAN[:ind]
__
d:each <- QUAN[:ind]
__
d:every<- QUAN
__
d:no   <- QUAN
__
d:several<-QUAN[:ind]
__
d:both <- QUAN[:ind]
__
d:multiple <- QUAN
__

d:there <- THERE
__

d:i    <- PRO[%nom]
__
d:you  <- PRO
__
d:he   <- PRO[%nom]
__
d:she  <- PRO[%nom]
__
d:it   <- PRO
__
d:we   <- PRO[%nom]
__
d:they <- PRO[%nom]
__
d:mine <- PRO
__
d:yours<- PRO
__
d:hers <- PRO
__
d:ours <- PRO
__
d:theirs<-PRO
__
d:him  <- PRO
__
d:them <- PRO
__
d:her  <- PRO
__
d:1    <- PRO[%mod]
_
  append one
__
d:someone <- PRO
__
d:anyone  <- PRO
__

d:and  <- CONJ
__
d:or   <- CONJ
__
d:but  <- CONJ
__
d:if   <- CONJ
__
d:so   <- CONJ
__
d:when <- CONJ
__
d:since<- CONJ
__
d:before<-CONJ
__
d:after<- CONJ
__
d:either<-CONJ
__
d:as   <- CONJ
__
d:despite <- CONJ
__
d:than    <- CONJ
__
d:except  <- CONJ
__

d:is   <- BE
__
d:am   <- BE
__
d:are  <- BE
__
d:was  <- BE
__
d:were <- BE
__
d:be   <- BE
__
d:been <- BE[^ed]
__
d:have <- HAVE
__
d:has  <- HAVE
 >>+
__
d:had  <- HAVE
 >>+
__
d:will <- AUXL
__
d:shall<- AUXL
__
d:would<- AUXL
__
d:should<-AUXL
__
d:can  <- AUXL
__
d:may  <- AUXL
__
d:might<- AUXL
__
d:must <- AUXL
__
d:could<- AUXL
__

d:in  <- PTCL
__
d:out <- PTCL
__
d:out <- PTCL
__

d:not  <- NEGN
__
d:never<- NEGN
__

#
# inflectional endings and morphological suffixes
d:-s   <- XS
__
d:-ed  <- XED
__
d:-n   <- XED
__
d:-t   <- XED
__
d:-ing <- XING
__
d:-er  <- XER
__
d:-est <- XEST
__
d:-'s  <- APOS
__

d:-ion  <- SUFX[#vTOn]
__
d:-ize  <- SUFX[#aTOv]
__
d:-ize  <- SUFX[#nTOv]
__
d:-ic   <- SUFX[#nTOa]
__
d:-al   <- SUFX[#nTOa]
__
d:-ar   <- SUFX[#nTOa]
__
d:-ate  <- SUFX[#nTOa]
__
d:-ment <- SUFX[#vTOn]
__
d:-ation<- SUFX[#vTOn]
__
d:-ly   <- SUFX[#aTOr]
__
d:-ly   <- SUFX[#nTOa]
__
d:-ful  <- SUFX[#nTOa]
__
d:-ous  <- SUFX[#nTOa]
__
d:-er   <- SUFX[#vTOn]
__
d:-or   <- SUFX[#vTOn]
__
d:-ingly<- SUFX[#vTOr]
__
d:-ist  <- SUFX[#aTOn]
__
d:-ist  <- SUFX[#nTOn]
__
d:-ive  <- SUFX[#vTOa]
__
d:-ory  <- SUFX[#vTOa]
__
d:-y <- SUFX[#nTOa]
__

d:[ <- PUNC[|*l]
__
d:] <- PUNC[|*r]
__
d:( <- PUNC[|*l]
__
d:) <- PUNC[|*r]
__
d:“ <- PUNC[|*l,quo] 
__
d:” <- PUNC[|*r,quo]
__
d:" <- PUNC[|*l,*r,quo]
__
d:‘ <- PUNC[|*l,quo]
__
d:’ <- PUNC[|*r,quo]
__
d:$ <- MONY
__
d:. <- PUNC[|emb]
__
d:! <- PUNC[|emb]
__
d:? <- PUNC[|emb]
__|
d:, <- PUNC[|com]
__

####

p:opnpl
_
  left
  delete 1 >
  store lbr
  right
__
p:clspr
_
  left
  right
  delete 1 >
  store rbr
__
d:[ <- OPNP
__
d:] <- CLSP
__
g:NOUN[:*r]->OPNP NOUN
_
  (opnpl)
__
g:NOUN[:*l]->NOUN CLSP
 >>+
_
  (clspr)
__
g:VERB[^*r]->OPNP VERB
_
  (opnpl)
__
g:VERB[^*l]->VERB CLSP
 >>+
_
  (clspr)
__
g:DET[:*r]->OPNP DET
_
  (opnpl)
__
g:DET[:*l]->DET CLSP
 >>+
_
  (clspr)
__
g:CONJ[:*r]->OPNP CONJ
_
  (opnpl)
__
g:CONJ[:*l]->CONJ CLSP
 >>+
_
  (clspr)
__
