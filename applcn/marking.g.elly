# add markup to convert English text into shallow XML
# marking.g.elly

#
# subprocedures
p:lxtd  # adding a left generated tagged element to a right generated list
_
  split
  right
  back
  delete to >
  store    tmp
  insert < tmp
  (typg)
  merge
__
p:typg  # left generation of element tagged as specified type
_
  append <
  insert < typg
  append >
  left
  append </
  insert < typg
  append >
__
p:twob  # default spaced output for 2-branch rule
_
  left
  space
  right
__

#
# syntax rules
g:SENT->SS
_
  append <sent>
  linefeed
  left
  append </sent>
__
g:SS->SS PUNC[~stop]
_
  left
  linefeed
  append <punc>
  right
  append </punc>
__
g:SS[|segm]->SEGM
__
g:SS[|segm]->SS[|-segm] SEGM
_
  left
  linefeed
  right
__
g:SS->SS PUNC[~-stop]
_
  left
  linefeed
  append <punc>
  right
  append </punc>
__
g:SS->SS CONJ
_
  left
  linefeed
  append <conj>
  right
  append </conj>
__
g:SS->CONJ
_
  var typg=conj
  (typg)
__

g:SEGM[|*unique]->ELEM
 >>*l
__
g:SEGM[|*unique]->SEGM ELEM
 l[!n] r[!n]>>*r--
 l[!v] r[!v]>>*r--
            >>*r
_
  left
  linefeed
  right
__

g:ELEM->NCLU[:-dit, prep]
__
g:ELEM->NCLU[:-dit,-prep]
 >>[!n]
__
g:ELEM->NCLU[:dit]
 >>[!n]+
_
  append <conj>that</conj>
  linefeed
  left
__
g:ELEM->MOD NCLU
_
  var typg=mod
  (lxtd)
__
g:ELEM->PRO
_
  var typg=pro
  (typg)
__
g:ELEM[^*l]->VCLU[^-to,-infn]
 >>[!v]
__
g:ELEM[^*l]->VCLU[^-to, infn]
__
g:ELEM->VCLU[^to] NCLU
 >>+
_
  left
  linefeed
  right
__
g:ELEM->THAT VCLU[^s]
 >>++
_
  append <dem>that</dem>
  right
__
g:ELEM->ELEM[^dit] THAT
 >>++
_
  left
  linefeed
  append <conj>that</conj>
__
g:ELEM->DATE
_
  var typg=date
  (typg)
__
g:ELEM->TIME
_
  var typg=time
  (typg)
__
g:ELEM->DEM[:ind]
 >>--
_
  var typg=dem
  (typg)
__
g:ELEM->APOS
_
  var typg=poss
  (typg)
__
g:ELEM->NUM
 >>-
_
  var typg=num
  (typg)
__
g:ELEM->ADV
 >>----
_
  var typg=adv
  (typg)
__
g:ELEM[^dit]->PEXP
_
  var typg=pexp
  (typg)
__

g:PEXP[|*r]->PUNC PEXP[|-*r]
 >>+
_
  (twob)
__
g:PEXP[|*l]->PEXP[|-*l] PUNC
 >>+
__

g:NCLU[:*l]->NOUN
_
  append <nclu>
  var typg=noun
  (typg)
  append </nclu>
__
g:NCLU[:*l,*r,det]->DET NCLU[:-det,-prep]
_
  var typg=det
  (lxtd)
__
g:NCLU[:*r,prep]->PREP NCLU[:-prep]
_
  var typg=prep
  (lxtd)
__
g:NCLU[:prep]->PREP YEAR
_
  append <time>
  (twob)
  append </time>
__
g:NCLU[:*l,*r,det]->DEM[:-sgl] NCLU[:-det,-prep]
_
  var typg=dem
  (lxtd)
__
g:NCLU[:*l,*r,det]->DEM[:sgl]  NCLU[:-det,-prep,-plur]
 >>++
_
  var typg=dem
  (lxtd)
__
g:NCLU[:*r]->ADJ NCLU[:-det,-prep,-num]
_
  var typg=adj
  (lxtd)
__
g:NCLU[:*r,num]-> NUM NCLU[:-det,-prep,-num]
_
  var typg=num
  (lxtd)
__
g:NCLU[:*r,det]->QUAN NCLU[:-det,-prep,-num]
_
  var typg=quan
  (lxtd)
__
g:NOUN->UNKN
__
g:NOUN->VERB SUFX[#vTOn]
_
  (twob)
__
g:NOUN->VERB XING
_
  (twob)
__
g:NOUN[:hyph]->NOUN[:-hyph] HYPH
__
g:NOUN[:*r]->NOUN[:hyph] NOUN
 >>++
__
g:ADJ[:*r]->NOUN[:hyph] ADJ
 >>++
__
g:NOUN[:*r,cjn]->NOUN[:-hyph,-plur,-cjn] NOUN[:-cjn]
 >>+
_
  (twob)
__

g:VCLU[^*l]->VERB
_
  append <vclu>
  var typg=verb
  (typg)
  append </vclu>
__
g:VCLU[^*r]->ADV VCLU
_
  var typg=adv
  (lxtd)
__
g:VCLU[^hav,*r]->HAVE VCLU[^-hav]
_
  var typg=asp
  (lxtd)
__
g:VCLU[^aux,*r]->AUXL VCLU[^-aux]
_
  var typg=aux
  (lxtd)
__
g:VCLU[^*r]->BE VCLU[^ing,-hav]
 >>++
_
  var typg=be
  (lxtd)
__
g:VCLU[^*r,pass]->BE VCLU[^ed,-hav]
_
  var typg=be
  (lxtd)
__

g:VERB->UNKN
 >>-
__
g:VERB[^*r,infn]->TO VERB[^-aux]
_
  (twob)
__
g:VERB->NOUN SUFX[#nTOv]
_
  (twob)
__
g:VERB->ADJ  SUFX[#aTOv]
_
  (twob)
__
g:VERB[:*r]->NOUN[:hyph] VERB
__
g:VERB[^beaj]->BE ADJ
_
  (twob)
__
g:VERB[^*l,to]->VERB[^beaj] TO
_
  (twob)
__
g:VERB->BE
 >>-
__
g:VERB->HAVE
 >>-
__

g:ADJ->NOUN SUFX[#nTOa]
_
  (twob)
__
g:ADJ[:*r]->NOUN[:hyph] ADJ
__
g:ADJ[:*r]->ADV ADJ
_
  (twob)
__

g:ADV->ADJ SUFX[#aTOr]
_
  (twob)
__
g:ADV->ADV ADV
 >>+
_
  (twob)
__

#
# simple inflections
g:NOUN[:*l,plur]->NOUN[:-*l,-*r] XS
_
  (twob)
__
g:NOUN[:plur]->UNKN XS
_
  (twob)
__
g:VERB[^*l,s]->VERB[^-*l,-*r] XS
_
  (twob)
__
g:VERB[^*l,ed]->VERB[^-*l,-*r] XED
 >>++
_
  (twob)
__
g:VERB[^*l,ing]->VERB[^-*l,-*r] XING
_
  (twob)
__
g:ADJ->ADJ[:-*l,-*r] XER
_
  (twob)
__
g:ADJ->ADJ[:-*l,-*r] XEST
_
  (twob)
__

#
# predicate negation
g:AUXL[^neg]->AUXL[^-neg] NEGN
_
  (twob)
__
g:BE[^neg]->BE[^-neg] NEGN
_
  (twob)
__

#
# special contextual check
g:DEM[:*r,dit]->THAT DEM
_
  right
__
g:DET[:*r,dit]->THAT DET
_
  right
__

#
# internal dictionary
d:- <- HYPH
__
d:in   <- PREP
__
d:of   <- PREP
__
d:on   <- PREP
__
d:by   <- PREP
__
d:into <- PREP
__
d:to   <- PREP
__
d:for  <- PREP
__
d:with <- PREP
__
d:from <- PREP
__
d:over <- PREP
__
d:outside <- PREP
__

d:to   <- TO
__

d:a    <- DET
__
d:an   <- DET
__
d:the  <- DET
__

d:this <- DEM[:ind,sgl]
__
d:that <- DEM[:ind,sgl]
__
d:that <- THAT
__
d:these<- DEM[:ind]
__
d:those<- DEM[:ind]
__
d:my   <- DEM
__
d:your <- DEM
__
d:his  <- DEM[:ind]
__
d:her  <- DEM
__
d:its  <- DEM
__
d:our  <- DEM
__
d:their<- DEM
__

d:who  <- CONJ
__
d:which<- CONJ
__

d:all  <- QUAN
__
d:some <- QUAN
__
d:many <- QUAN
__
d:each <- QUAN
__
d:every<- QUAN
__
d:no   <- QUAN
__
d:several<-QUAN
__

d:i    <- PRO
__
d:you  <- PRO
__
d:he   <- PRO
__
d:she  <- PRO
__
d:it   <- PRO
__
d:we   <- PRO
__
d:they <- PRO
__
d:mine <- PRO
__
d:yours<- PRO
__
d:hers <- PRO
__
d:ours <- PRO
__
d:theirs<-PRO
__

d:and  <- CONJ
__
d:or   <- CONJ
__
d:but  <- CONJ
__
d:if   <- CONJ
__
d:when <- CONJ
__
d:since<- CONJ
__
d:before<-CONJ
__
d:after<- CONJ
__
d:either<-CONJ
__

d:is   <- BE
__
d:am   <- BE
__
d:are  <- BE
__
d:was  <- BE
__
d:were <- BE
__
d:be   <- BE
__
d:been <- BE[^ED]
__
d:have <- HAVE
__
d:has  <- HAVE
 >>+
__
d:had  <- HAVE
 >>+
__
d:will <- AUXL
__
d:shall<- AUXL
__
d:would<- AUXL
__
d:should<-AUXL
__
d:can  <- AUXL
__
d:may  <- AUXL
__
d:might<- AUXL
__
d:must <- AUXL
__
d:could<- AUXL
__

d:not  <- NEGN
__
d:never<- NEGN
__

#
# inflectional endings and morphological suffixes
d:-s   <- XS
__
d:-ed  <- XED
__
d:-n   <- XED
__
d:-t   <- XED
__
d:-ing <- XING
__
d:-er  <- XER
__
d:-est <- XEST
__
d:-'s  <- APOS
__

d:-ion  <- SUFX[#vTOn]
__
d:-ize  <- SUFX[#aTOv]
__
d:-ic   <- SUFX[#nTOa]
__
d:-al   <- SUFX[#nTOa]
__
d:-ment <- SUFX[#vTOn]
__
d:-ation<- SUFX[#vTOn]
__
d:-ly   <- SUFX[#aTOr]
__
d:-ly   <- SUFX[#nTOa]
__
d:-ful  <- SUFX[#nTOa]
__
d:-ous  <- SUFX[#nTOa]
__
d:-er   <- SUFX[#vTOn]
__
